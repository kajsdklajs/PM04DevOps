<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Измеритель скорости интернета</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#3b82f6; --good:#22c55e; --warn:#f59e0b; --danger:#ef4444;
    --text:#e6eef8; --muted:rgba(230,238,248,0.6);
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; font-family:Inter, Roboto, system-ui, sans-serif;
    display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#071022,#07121a); color:var(--text);
    padding:20px;
  }
  .card{
    width:880px; max-width:95vw; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04); border-radius:12px; padding:18px; box-shadow:0 10px 40px rgba(0,0,0,0.6);
    display:grid; grid-template-columns: 1fr 320px; gap:16px;
  }
  h1{margin:0 0 6px 0;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:12px}
  button{background:var(--accent);color:#04122b;border:0;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);font-weight:600}
  input,select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
  label{font-size:13px;color:var(--muted)}
  .big {font-size:40px;font-weight:800}
  .meta{display:flex;flex-direction:column;gap:8px}
  .chart{width:100%;height:180px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border-radius:8px;padding:8px}
  .stat{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:12px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
  .row{display:flex;gap:8px}
  .rightcol{display:flex;flex-direction:column;gap:12px;align-items:stretch}
  .note{font-size:12px;color:var(--muted)}
  footer{grid-column:1/-1;text-align:center;font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
  <div class="card" role="application" aria-label="Измеритель скорости интернета">
    <div>
      <h1>Измеритель скорости интернета</h1>
      <div class="muted">Пинг, загрузка (download) и — при наличии подходящего сервера — выгрузка (upload). Результаты в Mbps.</div>

      <div style="margin-top:12px;display:flex;gap:12px;flex-wrap:wrap">
        <div>
          <label>Тестовый URL (download)</label><br>
          <select id="testUrl">
            <!-- Примеры: эти файлы обычно доступны, но могут быть заблокированы или без CORS -->
            <option value="https://speed.hetzner.de/100MB.bin">Hetzner 100MB (если доступен)</option>
            <option value="https://speed.hetzner.de/10MB.bin">Hetzner 10MB</option>
            <option value="https://ipv4.download.thinkbroadband.com/10MB.zip">thinkbroadband 10MB</option>
            <option value="">(Указать свой URL)</option>
          </select>
        </div>

        <div style="min-width:220px">
          <label>Свой URL (перезапишет выбор)</label><br>
          <input id="customUrl" placeholder="https://example.com/testfile.bin" style="width:100%"/>
        </div>

        <div style="min-width:220px">
          <label>Upload URL (опционально, POST, с CORS)</label><br>
          <input id="uploadUrl" placeholder="https://example.com/upload" style="width:100%"/>
        </div>
      </div>

      <div class="controls">
        <button id="startBtn">Запустить тест</button>
        <button id="stopBtn" class="secondary">Остановить</button>
        <button id="clearBtn" class="secondary">Сброс графика</button>
        <div style="margin-left:auto" class="note">Осторожно: upload тест отправляет данные на указанный сервер.</div>
      </div>

      <div style="display:flex;gap:12px;margin-top:12px">
        <div style="flex:1">
          <div class="chart" id="chartWrap">
            <canvas id="chart" width="640" height="180" style="width:100%;height:100%"></canvas>
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <div class="stat" style="flex:1">
              <div class="muted">Пинг (ms)</div>
              <div id="pingVal" class="big">—</div>
            </div>
            <div class="stat" style="flex:1">
              <div class="muted">Download</div>
              <div id="dlVal" class="big">—</div>
            </div>
            <div class="stat" style="flex:1">
              <div class="muted">Upload</div>
              <div id="ulVal" class="big">—</div>
            </div>
          </div>
        </div>

        <div class="rightcol">
          <div style="display:flex;flex-direction:column;gap:8px">
            <label>Повторять тест download (кол-во файлов)</label>
            <input id="repeatCount" type="number" min="1" max="10" value="3" />
          </div>

          <div style="display:flex;flex-direction:column;gap:8px">
            <label>Размер файла при upload (KB)</label>
            <input id="uploadSize" type="number" min="10" max="5000" value="200" />
            <div class="note">Upload выполняется в виде POST (blob) к указанному upload URL.</div>
          </div>

          <div style="display:flex;flex-direction:column;gap:6px">
            <label>История (последние значения):</label>
            <div id="history" class="note">—</div>
          </div>

          <div style="display:flex;flex-direction:column;gap:6px">
            <label>Логи</label>
            <textarea id="log" style="height:120px;background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px"></textarea>
          </div>
        </div>
      </div>

    </div>

    <footer>Примечание: браузерные тесты измеряют сетевой путь до выбранного сервера и не всегда отражают пиковую пропускную способность провайдера.</footer>
  </div>

<script>
/* Утилиты */
function nowMs(){ return performance.now(); }
function log(msg){ const t=new Date().toLocaleTimeString(); document.getElementById('log').value = (t+' — '+msg + '\\n') + document.getElementById('log').value; }
function bytesToMbps(bytes, seconds){ if(seconds<=0) return 0; return (bytes*8)/(seconds*1000*1000); } // Мбит/с

/* DOM */
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const clearBtn = document.getElementById('clearBtn');
const testUrlSelect = document.getElementById('testUrl');
const customUrl = document.getElementById('customUrl');
const uploadUrlInput = document.getElementById('uploadUrl');
const repeatCountInput = document.getElementById('repeatCount');
const uploadSizeInput = document.getElementById('uploadSize');

const pingVal = document.getElementById('pingVal');
const dlVal = document.getElementById('dlVal');
const ulVal = document.getElementById('ulVal');
const historyEl = document.getElementById('history');

const chartCanvas = document.getElementById('chart');
const ctx = chartCanvas.getContext('2d');

let running = false;
let abortControllers = [];

/* Chart state */
let samples = []; // массив {t, dl, ul, ping}
function drawChart(){
  const w = chartCanvas.width;
  const h = chartCanvas.height;
  ctx.clearRect(0,0,w,h);
  // background grid
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(0,0,w,h);
  // draw axes lines
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.beginPath();
  for(let i=0;i<=4;i++){
    const y = h - (i*(h/4));
    ctx.moveTo(0,y); ctx.lineTo(w,y);
  }
  ctx.stroke();

  if(samples.length===0) return;
  // scale: find max among dl and ul
  const maxMbps = Math.max(...samples.map(s=>Math.max(s.dl||0,s.ul||0)), 1);
  // draw download (blue)
  ctx.lineWidth=2; ctx.strokeStyle='rgba(59,130,246,0.95)'; ctx.beginPath();
  samples.forEach((s,i)=>{
    const x = i/(samples.length-1) * w;
    const y = h - ( (s.dl||0)/maxMbps * (h-10) );
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
  // draw upload (orange)
  ctx.lineWidth=2; ctx.strokeStyle='rgba(245,158,11,0.95)'; ctx.beginPath();
  samples.forEach((s,i)=>{
    const x = i/(samples.length-1) * w;
    const y = h - ( (s.ul||0)/maxMbps * (h-10) );
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
  // draw ping dots
  ctx.fillStyle='rgba(255,255,255,0.9)';
  samples.forEach((s,i)=>{
    const x = i/(samples.length-1) * w;
    const y = h - ( (s.dl||0)/maxMbps * (h-10) );
    ctx.fillRect(x-1, y-1, 3, 3);
  });
}

/* Ping: выполняем серию коротких запросов (HEAD или small fetch) */
async function measurePing(url, count=4, timeout=3000){
  // choose a lightweight endpoint on same server: try HEAD
  let times = [];
  for(let i=0;i<count;i++){
    try{
      const controller = new AbortController();
      abortControllers.push(controller);
      const start = nowMs();
      const resp = await fetch(url, { method: 'HEAD', cache: 'no-store', signal: controller.signal });
      const elapsed = (nowMs() - start);
      // if server doesn't accept HEAD, fallback to GET small range
      if(!resp.ok){
        // try GET with range request for first bytes
        const controller2 = new AbortController();
        abortControllers.push(controller2);
        const st = nowMs();
        const r = await fetch(url, { method: 'GET', headers: { 'Range': 'bytes=0-1023' }, cache:'no-store', signal: controller2.signal });
        const el = nowMs() - st;
        times.push(el);
      } else {
        times.push(elapsed);
      }
    }catch(err){
      log('Ping error: ' + err.message);
      times.push(timeout);
    }
  }
  // average, ignoring extremes
  times = times.filter(t=>isFinite(t));
  if(times.length===0) return Infinity;
  const avg = times.reduce((a,b)=>a+b,0)/times.length;
  return Math.round(avg);
}

/* Download: скачиваем файл, измеряем скорость.
   Мы загружаем как blob (response.blob()), чтобы точно считать байты.
   Для больших файлов ставим cache: 'no-store' и добавляем query param уникальности
*/
async function measureDownload(url, onProgress=null){
  const unique = url + (url.includes('?')? '&' : '?') + 'cacheBuster=' + Date.now() + Math.random();
  const controller = new AbortController();
  abortControllers.push(controller);
  const start = nowMs();
  let bytes = 0;
  try {
    const resp = await fetch(unique, { method:'GET', cache:'no-store', signal: controller.signal });
    if(!resp.ok) throw new Error('HTTP ' + resp.status);
    // If response body supports streaming, use reader to get progressive progress
    const reader = resp.body && resp.body.getReader ? resp.body.getReader() : null;
    if(reader){
      while(true){
        const { done, value } = await reader.read();
        if(done) break;
        bytes += value.byteLength;
        if(onProgress) onProgress(bytes, nowMs() - start);
      }
    } else {
      const blob = await resp.blob();
      bytes = blob.size;
      if(onProgress) onProgress(bytes, nowMs() - start);
    }
    const elapsed = (nowMs() - start) / 1000; // сек
    const mbps = bytesToMbps(bytes, elapsed);
    return { ok:true, bytes, seconds: elapsed, mbps };
  } catch(err){
    log('Download error: ' + err.message);
    return { ok:false, error: err.message };
  }
}

/* Upload: отправляем сгенерированные данные (Blob) методом POST на uploadUrl.
   Сервер должен принимать CORS и отвечать. Если не указано - пропускаем.
*/
async function measureUpload(uploadUrl, sizeKB=200, onProgress=null){
  if(!uploadUrl) return { ok:false, error:'Upload URL not set' };
  // generate random data
  const size = Math.max(10, sizeKB) * 1024;
  const chunk = new Uint8Array(64*1024);
  crypto.getRandomValues(chunk);
  // build blob by repeating chunk
  const chunks = [];
  let need = size;
  while(need > 0){
    chunks.push(chunk.slice(0, Math.min(chunk.length, need)));
    need -= chunk.length;
  }
  const blob = new Blob(chunks, { type: 'application/octet-stream' });

  try {
    const controller = new AbortController();
    abortControllers.push(controller);
    const start = nowMs();
    // fetch doesn't expose upload progress in standard way; use XMLHttpRequest for progress events
    const result = await new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', uploadUrl, true);
      xhr.responseType = 'text';
      xhr.timeout = 30000;
      xhr.onload = () => {
        const elapsed = (nowMs() - start)/1000;
        const bytes = blob.size;
        const mbps = bytesToMbps(bytes, elapsed);
        resolve({ ok:true, bytes, seconds: elapsed, mbps, status: xhr.status });
      };
      xhr.onerror = () => reject(new Error('XHR upload error'));
      xhr.ontimeout = () => reject(new Error('XHR upload timeout'));
      xhr.upload.onprogress = (e) => {
        if(onProgress && e.lengthComputable) onProgress(e.loaded, e.total, nowMs()-start);
      };
      xhr.send(blob);
    });
    return result;
  } catch(err){
    log('Upload error: ' + err.message);
    return { ok:false, error: err.message };
  }
}

/* Главная логика теста */
async function runTest(){
  if(running) return;
  running = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  abortControllers = [];

  // choose URL
  let url = '';
  if(customUrl.value && customUrl.value.trim() !== '') url = customUrl.value.trim();
  else url = testUrlSelect.value;
  if(!url){
    alert('Укажите URL для теста download (или выберите из списка).');
    running = false; startBtn.disabled=false; stopBtn.disabled=true;
    return;
  }
  const uploadUrl = uploadUrlInput.value.trim() || '';
  const repeats = Math.max(1, Math.min(10, Number(repeatCountInput.value) || 3));

  samples = [];
  updateUI();

  try {
    log('Start ping...');
    const pingMs = await measurePing(url, 4);
    pingVal.textContent = (isFinite(pingMs) ? pingMs + ' ms' : '—');
    log('Ping: ' + pingMs + ' ms');
  } catch(e){
    log('Ping failed: ' + e.message);
  }

  // sequential download tests (repeats) - collects several samples
  for(let i=0;i<repeats && running;i++){
    log(`Download #${i+1} start`);
    const onProgress = (bytes, ms) => {
      // live update: compute current Mbps
      const mbpsNow = bytesToMbps(bytes, ms/1000);
      // display instant
      dlVal.textContent = mbpsNow.toFixed(2) + ' Mbps';
    };
    const res = await measureDownload(url, onProgress);
    if(!running) break;
    if(res.ok){
      log(`Download #${i+1} done: ${res.mbps.toFixed(2)} Mbps (${res.bytes} bytes in ${res.seconds.toFixed(2)}s)`);
      samples.push({ t: Date.now(), dl: Number(res.mbps.toFixed(2)), ul: 0, ping: pingVal.textContent });
      dlVal.textContent = res.mbps.toFixed(2) + ' Mbps';
    } else {
      log('Download failed: ' + res.error);
      samples.push({ t: Date.now(), dl: 0, ul:0, ping: pingVal.textContent });
      dlVal.textContent = 'err';
    }
    drawChart();
    updateHistory();
  }

  // upload (if URL provided)
  if(uploadUrl && running){
    log('Upload start...');
    const resU = await measureUpload(uploadUrl, Number(uploadSizeInput.value) || 200, (loaded,total,ms)=>{
      const mbps = bytesToMbps(loaded, ms/1000);
      ulVal.textContent = mbps.toFixed(2) + ' Mbps';
    });
    if(resU.ok){
      log(`Upload done: ${resU.mbps.toFixed(2)} Mbps (${resU.bytes} bytes in ${resU.seconds.toFixed(2)}s)`);
      ulVal.textContent = resU.mbps.toFixed(2) + ' Mbps';
      // attach to last sample
      if(samples.length>0) samples[samples.length-1].ul = Number(resU.mbps.toFixed(2));
      else samples.push({ t: Date.now(), dl:0, ul: Number(resU.mbps.toFixed(2)), ping: pingVal.textContent });
    } else {
      log('Upload failed: ' + resU.error);
      ulVal.textContent = 'err';
    }
    drawChart();
    updateHistory();
  } else {
    log('Upload skipped (no upload URL)');
  }

  running = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

/* update history text and stats */
function updateHistory(){
  const last = samples.slice(-5).reverse();
  historyEl.textContent = last.map(s=>`${s.dl||0} / ${s.ul||0} Mbps`).join(' · ');
}

/* update UI initial */
function updateUI(){
  drawChart();
}

/* stop routine */
function stopAll(){
  running = false;
  abortControllers.forEach(c=>{
    try{ c.abort(); }catch(e){}
  });
  abortControllers = [];
  startBtn.disabled = false;
  stopBtn.disabled = true;
  log('Tests stopped by user');
}

/* clear */
function clearAll(){
  samples=[];
  drawChart();
  pingVal.textContent = '—';
  dlVal.textContent = '—';
  ulVal.textContent = '—';
  historyEl.textContent = '—';
  document.getElementById('log').value = '';
}

/* events */
startBtn.addEventListener('click', ()=>{ runTest().catch(e=>{ log('Run error: '+e.message); running=false; startBtn.disabled=false; stopBtn.disabled=true; }); });
stopBtn.addEventListener('click', stopAll);
clearBtn.addEventListener('click', clearAll);

/* responsiveness: scale canvas for high-DPI */
function fixCanvasDPR(){
  const rect = chartCanvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  chartCanvas.width = Math.floor(rect.width * dpr);
  chartCanvas.height = Math.floor(rect.height * dpr);
  chartCanvas.style.width = rect.width + 'px';
  chartCanvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  drawChart();
}
window.addEventListener('resize', fixCanvasDPR);
setTimeout(fixCanvasDPR, 10);

/* keyboard: Enter triggers start */
document.addEventListener('keydown', (e)=>{ if(e.key==='Enter') startBtn.click(); });

</script>
</body>
</html>
